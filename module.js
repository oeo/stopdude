// Generated by CoffeeScript 2.7.0
(function() {
  var EventEmitter, Throttle, _, englishSecs,
    indexOf = [].indexOf;

  require('date-utils');

  _ = require('lodash');

  englishSecs = require('english-secs');

  ({EventEmitter} = require('events'));

  module.exports = Throttle = (function() {
    class Throttle {
      constructor(opt = {}) {
        if (opt.prefix == null) {
          opt.prefix = 'stopdude';
        }
        this.opt = opt;
        [this.redis, this.prefix] = [opt.redis, opt.prefix];
        // Properly set up EventEmitter
        EventEmitter.call(this);
        Object.assign(this, EventEmitter.prototype);
      }

      async create(opt) {
        var dictKey, dictMember, exists, i, len, r, ref, ref1, ruleDoc, ruleHash, uu, x;
        ref = ['key', 'max', 'time'];
        for (i = 0, len = ref.length; i < len; i++) {
          x = ref[i];
          if (!opt[x]) {
            throw new Error(`Option ${x} is required`);
          }
        }
        if (ref1 = opt.time, indexOf.call(this.timeSegments, ref1) < 0) {
          throw new Error(`Time segment ${opt.time} was invalid`);
        }
        exists = (await this.find(opt.key));
        if (exists) {
          return exists;
        }
        uu = this.generateUUID();
        dictKey = [this.prefix, 'rules', '_dict'];
        dictMember = `${uu}=${opt.key}`;
        await this.redis.sadd(dictKey.join(':'), dictMember);
        ruleHash = [this.prefix, 'rules', uu];
        ruleDoc = {
          _id: uu,
          key: opt.key,
          max: opt.max,
          time: opt.time,
          ctime: this.getTime()
        };
        await this.redis.hmset(ruleHash.join(':'), ruleDoc);
        r = (await this.find(opt.key));
        this.emit('ruleCreated', r);
        return r;
      }

      async find(key) {
        var i, id, len, r, ref, ruleHash, x;
        id = (await this.findId(key));
        if (!id) {
          return false;
        }
        ruleHash = [this.prefix, 'rules', id];
        r = (await this.redis.hgetall(ruleHash.join(':')));
        ref = ['max', 'ctime'];
        for (i = 0, len = ref.length; i < len; i++) {
          x = ref[i];
          try {
            r[x] = parseInt(r[x]);
          } catch (error) {}
        }
        return r;
      }

      async findId(key) {
        var dictKey, i, id, len, list, ruleKey, uu, x;
        dictKey = [this.prefix, 'rules', '_dict'];
        list = (await this.redis.smembers(dictKey.join(':')));
        id = false;
        if (list.length) {
          for (i = 0, len = list.length; i < len; i++) {
            x = list[i];
            [uu, ruleKey] = x.split('=');
            if (ruleKey === key) {
              id = uu;
              break;
            }
          }
        }
        return id;
      }

      async update(key, props) {
        var id, k, ruleHash, updateObj, v;
        id = (await this.findId(key));
        if (!id) {
          return false;
        }
        updateObj = {
          utime: this.getTime()
        };
        for (k in props) {
          v = props[k];
          if (k !== 'time' && k !== 'max') {
            continue;
          }
          if (k === 'time' && indexOf.call(this.timeSegments, v) < 0) {
            throw new Error(`Time value ${v} was invalid`);
          }
          updateObj[k] = v;
        }
        if (!_.size(updateObj)) {
          throw new Error('Properties provided were invalid');
        }
        ruleHash = [this.prefix, 'rules', id];
        await this.redis.hmset(ruleHash.join(':'), updateObj);
        this.emit('ruleUpdated', key);
        return true;
      }

      async incr(key, amount = 1) {
        var baseKey, exists, i, id, k, len, ref, statsKeys, timeStr, v;
        id = (await this.findId(key));
        if (!id) {
          return false;
        }
        baseKey = [this.prefix, 'counters', id];
        statsKeys = {};
        ref = this.timeSegments;
        for (i = 0, len = ref.length; i < len; i++) {
          timeStr = ref[i];
          statsKeys[timeStr] = {
            key: baseKey.concat([timeStr]).join(':'),
            expires: this.getExpires(timeStr),
            amount: amount
          };
        }
        for (k in statsKeys) {
          v = statsKeys[k];
          exists = (await this.redis.exists(v.key));
          await this.redis.incrby(v.key, amount);
          if (!exists) {
            await this.redis.expireat(v.key, v.expires);
            this.emit('counterCreated', v.key);
          }
          this.emit('counterIncremented', v.key);
        }
        return true;
      }

      async clear(key) {
        var baseKey, i, id, len, m, ref, timeStr;
        id = (await this.findId(key));
        if (!id) {
          return false;
        }
        baseKey = [this.prefix, 'counters', id];
        m = this.redis.multi();
        ref = this.timeSegments;
        for (i = 0, len = ref.length; i < len; i++) {
          timeStr = ref[i];
          m.del(baseKey.concat([timeStr]).join(':'));
        }
        await m.exec();
        this.emit('countersCleared', key);
        return true;
      }

      async remove(key) {
        var baseKey, dictKey, dictVal, i, id, len, m, ref, ruleHash, timeStr;
        id = (await this.findId(key));
        if (!id) {
          return false;
        }
        m = this.redis.multi();
        dictKey = [this.prefix, 'rules', '_dict'];
        dictVal = `${id}=${key}`;
        m.srem(dictKey.join(':'), dictVal);
        ruleHash = [this.prefix, 'rules', id];
        m.del(ruleHash.join(':'));
        baseKey = [this.prefix, 'counters', id];
        ref = this.timeSegments;
        for (i = 0, len = ref.length; i < len; i++) {
          timeStr = ref[i];
          m.del(baseKey.concat([timeStr]).join(':'));
        }
        await m.exec();
        this.emit('ruleRemoved', key);
        return true;
      }

      async stats(key) {
        var baseKey, counters, i, len, m, r, ref, response, rule, start, timeStr;
        start = new Date();
        rule = (await this.find(key));
        if (!rule) {
          return false;
        }
        baseKey = [this.prefix, 'counters', rule._id];
        m = this.redis.multi();
        ref = this.timeSegments;
        for (i = 0, len = ref.length; i < len; i++) {
          timeStr = ref[i];
          m.get(baseKey.concat([timeStr]).join(':'));
        }
        r = (await m.exec());
        counters = _.zipObject(this.timeSegments, _.map(r, function(item) {
          if (!item[1]) {
            return 0;
          }
          return parseInt(item[1]);
        }));
        response = {
          allowed: (function() {
            var counter;
            if ((counter = counters[rule.time]) && rule.max) {
              if (counter >= rule.max) {
                return false;
              }
            }
            return true;
          })(),
          counters: counters,
          percent: (function() {
            var counter;
            if ((counter = counters[rule.time]) && rule.max) {
              if (counter >= rule.max) {
                return 100..toFixed(2);
              }
              if (counter > 0) {
                return ((counter / rule.max) * 100).toFixed(2);
              }
            }
            return 0..toFixed(2);
          })(),
          _meta: {
            elapsed: new Date() - start,
            rule: rule
          }
        };
        return response;
      }

      getExpires(timeStr) {
        var nextDay, nextHr, nextMin, nextMo, nextWk, now;
        now = Math.floor(Date.now() / 1000);
        nextMin = () => {
          return now + 60;
        };
        nextHr = () => {
          return now + 3600;
        };
        nextDay = () => {
          return now + 86400;
        };
        nextWk = () => {
          return now + 604800;
        };
        nextMo = () => {
          return now + 2592000; // Assuming 30 days in a month
        };
        switch (timeStr) {
          case 'minute':
            return nextMin();
          case 'hour':
            return nextHr();
          case 'day':
            return nextDay();
          case 'week':
            return nextWk();
          case 'month':
            return nextMo();
          default:
            throw new Error(`Time value ${timeStr} was invalid`);
        }
      }

      generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
          var r, v;
          r = Math.random() * 16 | 0;
          v = c === 'x' ? r : r & 0x3 | 0x8;
          return v.toString(16);
        });
      }

      secsToTime(str) {
        return englishSecs(str);
      }

      getTime() {
        return Math.floor(new Date().getTime() / 1000);
      }

      getMinute(unixInput = null) {
        var d;
        d = new Date();
        if (unixInput) {
          d = new Date(unixInput * 1000);
        }
        d.setMinutes(new Date().getMinutes(), 0, 0);
        return Math.round(d.getTime() / 1000);
      }

      getHour(unixInput = null) {
        var d;
        d = new Date();
        if (unixInput) {
          d = new Date(unixInput * 1000);
        }
        d.setHours(new Date().getHours(), 0, 0, 0);
        return Math.round(d.getTime() / 1000);
      }

      getType(obj) {
        if (obj === void 0 || obj === null) {
          return false;
        }
        return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();
      }

    };

    Throttle.prototype.timeSegments = ['minute', 'hour', 'day', 'week', 'month'];

    return Throttle;

  }).call(this);

  // vim: set ts=2 sw=2 et

}).call(this);
